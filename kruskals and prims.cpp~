#include <iostream>
#include <cstdlib>		// qsort
#include <cstring>		// NULL
#include <climits>		// INT_MAX

using namespace std;

const int INFINITY = INT_MAX;	// Used for prims



// ****************************************************************
//
//			      Edge
//
// ****************************************************************



struct Node{
    int src;
    int dest;
    int weight;
    Node* next;
};



// ****************************************************************
//
//                            List
//
// ****************************************************************



struct List{
  int size;
  Node* head;  
};



// ****************************************************************
//
//                           Graph
//
// ****************************************************************



class Graph{
  public:
    int vertices;
    int edges;
  
    Node* edge;
    List* array;

    Node* add_edge(const int node, int src, int dest, int w){
      Node* newEdge = new Node;
      newEdge->src = src;
      newEdge->dest = dest;
      newEdge->weight = w;
      newEdge->next = NULL;

      return newEdge;
    }

    void add_node(const int node, int src, int dest, int w){
      Node* newEdge = add_edge(node, src, dest, w);
      
      newEdge->next = array[src].head;
      array[src].head = newEdge;
      
      newEdge->next = array[dest].head;
      array[dest].head = newEdge;
      
      edge[node] = *newEdge;
    }
    

    int get_vertices(){ return vertices; }
    int get_edges() { return edges; }
    Node* get_edge(){ return edge; }
    Node get_single_edge(int num){ return edge[num]; }
};



// ****************************************************************



struct Graph* create_graph(int v, int e){
  Graph* graph = (Graph*)malloc(sizeof(Graph));

  graph->vertices = v;
  graph->edges = e;
  
  graph->edge = (Node*)malloc(graph->edges * sizeof(Node));
  graph->array = (List*)malloc(graph->edges * sizeof(List));
  
  for(int i = 0; i < graph->vertices; i++){
    graph->array[i].head = NULL;
  }
  
  return graph;
}



// ****************************************************************
//
//                        Other Helpers
//
// ****************************************************************



struct Subtree{
  int head;
  int numElements;
};


struct PrimHelper{
  int key;
  int parent;
};



// ****************************************************************

// ****************************************************************



void Kruskals(Graph* graph);
void Prims(Graph* graph);

int find(Subtree subtrees[], int findMe);
void Union(Subtree subtrees[], int v1, int v2);
int Compare(const void * a, const void * b);

int GetMin(List* Q, PrimHelper t[5], int value);



// ****************************************************************
//
//			     Main
//
// ****************************************************************



int main(){
  int numV = 5;
  int numE = 7;
  Graph *g = create_graph(numV, numE);
  

/*
       (2)
    5 /   \ 4
     /     \
   (1)--9--(3)
    |      /|
    |    /  |
    7   2   2
    |  /    |
    |/      |
   (0)--1--(4)
        

*/


  g->add_node(0, 0, 1, -7);
  g->add_node(1, 0, 3, 2);
  g->add_node(2, 0, 4, 1);
  g->add_node(3, 1, 2, 5);
  g->add_node(4, 1, 3, 9);
  g->add_node(5, 2, 3, 4);
  g->add_node(6, 3, 4, -2);
  
  Kruskals(g);
  Prims(g);

  return 0;
}



// ****************************************************************
//
//			Kruskal's Algoritm
//
// ****************************************************************



void Kruskals(Graph* graph){
  Graph* g = graph;
  int v = g->get_vertices();
  Node result[v];		// Stores the result of the MST
  int numEdges = 0;
  int sortedEdges = 0;


  // Sort all the edges in order by weight using quicksort
  qsort(g->get_edge(), g->get_edges(), sizeof(g->get_single_edge(0)), Compare);


  // Test the sorted graph
/*  cout << endl << "Testing Graph: ";

  for(int i = 0; i < 7; i++)
    cout << endl << g->edge[i].src << " " << g->edge[i].dest << " " <<  g->edge[i].weight;
  cout << endl << endl;
*/
  
  // Allocate Memory
  Subtree *subtrees = (Subtree*)malloc( v * sizeof(Subtree) );

  
  // Create v Subtrees
  for(int i = 0; i < v; i++){
    subtrees[i].head = i;
    subtrees[i].numElements = 0;
  }
  

  
  while(numEdges < v-1){
    Node next = g->get_single_edge(sortedEdges);
    
    int src = find(subtrees, next.src);
    int dest = find(subtrees, next.dest);

    if(src != dest){
      result[numEdges++] = next;
      Union(subtrees, src, dest);
    }
    sortedEdges++;
  }
  
  
  cout << endl << "Kruskals: " << endl;
  for(int i = 0; i < numEdges; i++){

    cout << endl << result[i].src << " -> " << result[i].dest;
  }
  cout << endl << endl;

}



// ****************************************************************
// ****************************************************************
// ****************************************************************
//
//                          WORKING HERE
//
// ****************************************************************
// ****************************************************************
// ****************************************************************




// ****************************************************************
//
//			  Prim's Algorithm
//
// ****************************************************************



void Prims(Graph* graph){
  Graph g = *graph;
  int V = g.vertices;
  List* Q;
  PrimHelper t[5];
  int lastNode = 0;		// Holds the integer value of the last node visited
  
  // Set up Q
  Q = (List*)malloc(graph->vertices * sizeof(List));  
  Q = g.array;
  
  // Set all keys to infinity and all parents to NULL
  for(int i = 0; i<5; i++){
    t[i].key = INFINITY;
    t[i].parent = NULL;
  }
  
  // Pick starting node 0 and set it's key to 0
  t[0].key = 0;

  // Update keys nearby
  

  // Get Minimum
  lastNode = GetMin(Q, t, lastNode);


  cout << "Prims:" << endl << endl;
cout << endl << lastNode;

/*
  Node* temp;
  for(int i = 0; i < 5; i++){
    temp = graph->array[i].head;
    
    while(temp->next != NULL){
      temp = temp->next;
      cout << temp->src << " -(" <<  temp->weight << ")-> " <<  temp->dest << endl;
    }
  }
  cout << endl << "____________" << endl << endl;;
  cout << graph->array[0].head->src << " -" <<  graph->array[0].head->weight << "-> " <<  graph->array[0].head->dest << endl;
  cout << graph->array[1].head->src << " -" <<  graph->array[1].head->weight << "-> " <<  graph->array[1].head->dest << endl;
  cout << graph->array[2].head->src << " -" <<  graph->array[2].head->weight << "-> " <<  graph->array[2].head->dest << endl;
  cout << graph->array[3].head->src << " -" <<  graph->array[3].head->weight << "-> " <<  graph->array[3].head->dest << endl;
  cout << graph->array[4].head->src << " -" <<  graph->array[4].head->weight << "-> " <<  graph->array[4].head->dest << endl;
  */
  
}



// ****************************************************************
//
//		      Kruskal Helper Functions
//
// ****************************************************************



// Finds the head of the subtree with the specified element
int find(Subtree subtrees[], int findMe) {

  if(subtrees[findMe].head != findMe)
    subtrees[findMe].head = find(subtrees, subtrees[findMe].head);

  return subtrees[findMe].head;
}



// ****************************************************************



// Combines two subtrees
void Union(Subtree subtrees[], int v1, int v2){
  int vt1 = find(subtrees, v1);
  int vt2 = find(subtrees, v2);



// Find the tree with the lower amount of elements and combine it to the bigger one

  // If vt1 has more elements than vt2
  // Add vt1 to vt2
  if(subtrees[vt1].numElements < subtrees[vt2].numElements){
    subtrees[vt1].head = vt2;
  }

  // If vt1 has less elements than vt2
  // Add vt2 to vt1
  else if(subtrees[vt1].numElements > subtrees[vt2].numElements){
    subtrees[vt2].head = vt1;
  }

  // If vt1 = vt2
  // Then set vt2's head to vt1
  else {
    subtrees[vt2].head = vt1;
    subtrees[vt1].numElements++;
  }

}



// ****************************************************************



// Used for the qsort function
int Compare(const void * a, const void * b){
  Node * a1 = (Node*)a;
  Node * b1 = (Node*)b;

  return a1->weight > b1->weight;
}


// ****************************************************************
//
//                      Prim Helper Functions
//
// ****************************************************************



int GetMin(List* Q, PrimHelper t[5], int value){
  int min = INFINITY;
  int minVal = INFINITY;
  Node* temp = new Node;
  
  temp = Q[value].head;
  
  // Get Minimum
  
// ****************************************************
// ***************** MAY NOT GET THE LAST ELEMENT 
// ****************************************************
  while(temp->next){
    if(temp->weight < minVal) {
      minVal = temp->weight;
      
      if(temp->src != value){
        min = temp->src;
      }
      else {
        min = temp->dest;
      }
    }
  }
  
  return min;
}



void UpdateKeys(List* Q, PrimHelper t[5], int value){
  

}
