#include <iostream>
#include <cstdlib>		// qsort
#include <cstring>		// NULL
#include <climits>		// INT_MAX

using namespace std;

const int INFINITY = INT_MAX;	// Used for prims



// ****************************************************************
//
//			      Edge
//
// ****************************************************************



struct Edge{
    int src;
    int dest;
    int weight;
};



// ****************************************************************
//
//                           Graph
//
// ****************************************************************



class Graph{
  public:
    int vertices;
    int edges;
  
    Edge* edge;

    void add_node(const int node, int src, int dest, int w){
      edge[node].src = src;
      edge[node].dest = dest;
      edge[node].weight = w;
    }

  int get_vertices(){ return vertices; }
  int get_edges() { return edges; }
  Edge* get_edge(){ return edge; }
  Edge get_single_edge(int num){ return edge[num]; }
};



// ****************************************************************



struct Graph* create_graph(int v, int e){
  Graph* graph = (Graph*)malloc(sizeof(Graph));

  graph->vertices = v;
  graph->edges = e;
  
  graph->edge = (Edge*)malloc(graph->edges * sizeof(Edge));

  return graph;
}



// ****************************************************************
//
//                        Other Helpers
//
// ****************************************************************



struct Subtree{
  int head;
  int numElements;
};


struct PrimHelper{
  int weight;
  int parent;
};



// ****************************************************************

// ****************************************************************



void Kruskals(Graph* graph);
void Prims(Graph* graph);

int find(Subtree subtrees[], int findMe);
void Union(Subtree subtrees[], int v1, int v2);
int Compare(const void * a, const void * b);



// ****************************************************************
//
//			     Main
//
// ****************************************************************



int main(){
  int numV = 5;
  int numE = 7;
  Graph *g = create_graph(numV, numE);
  

/*
       (2)
    5 /   \ 4
     /     \
   (1)--9--(3)
    |      /|
    |    /  |
    7   2   2
    |  /    |
    |/      |
   (4)--1--(5)
        

*/

  g->add_node(0, 1, 2, 5);
  g->add_node(1, 1, 3, 9);
  g->add_node(2, 1, 0, -7);
  g->add_node(3, 2, 3, 4);
  g->add_node(4, 3, 4, -2);
  g->add_node(5, 3, 0, 2);
  g->add_node(6, 4, 0, 1);
  

//  Kruskals(g);
  Prims(g);

  return 0;
}



// ****************************************************************
//
//			Kruskal's Algoritm
//
// ****************************************************************



void Kruskals(Graph* graph){
  Graph* g = graph;
  int v = g->get_vertices();
  Edge result[v];		// Stores the result of the MST
  int numEdges = 0;
  int sortedEdges = 0;


  // Sort all the edges in order by weight using quicksort
  qsort(g->get_edge(), g->get_edges(), sizeof(g->get_single_edge(0)), Compare);


  // Test the sorted graph
/*  cout << endl << "Testing Graph: ";

  for(int i = 0; i < 7; i++)
    cout << endl << g->edge[i].src << " " << g->edge[i].dest << " " <<  g->edge[i].weight;
  cout << endl << endl;
*/
  
  // Allocate Memory
  Subtree *subtrees = (Subtree*)malloc( v * sizeof(Subtree) );

  
  // Create v Subtrees
  for(int i = 0; i < v; i++){
    subtrees[i].head = i;
    subtrees[i].numElements = 0;
  }
  

  
// It's eating a line here
// for(numEdges = 0; numEdges < v; numEdges++){
  while(numEdges < v-1){
    Edge next = g->get_single_edge(sortedEdges);
    
    int src = find(subtrees, next.src);
    int dest = find(subtrees, next.dest);

    if(src != dest){
      result[numEdges++] = next;
      Union(subtrees, src, dest);
    }
    sortedEdges++;
  }
  
  
  cout << endl << "Kruskals: " << endl;
  for(int i = 0; i < numEdges; i++){

    cout << endl << result[i].src << " -> " << result[i].dest /*<< "   = " << result[i].weight*/;
  }
  cout << endl << endl;

}
// ****************************************************************
// ****************************************************************
// ****************************************************************
//
//                          WORKING HERE
//
// ****************************************************************
// ****************************************************************
// ****************************************************************




// ****************************************************************
//
//			  Prim's Algorithm
//
// ****************************************************************



void Prims(Graph* graph){
  Graph g = *graph;
  int * visited;
  PrimHelper t[5];
  int arrSize = 5;
  int * Q;
  
  // Put all of the vertices in a list
  for(int i = 0; i <5; i++) {
    Q = new int;
    Q[i] = i;
  }
  
  for(int i =0; i<5; i++){
    cout << " " << Q[i];
  }
  cout << endl;
  
  // Set all key's to infinity and all parents to NULL
  for(int i = 0; i < 5; i++){
    t[i].weight = INFINITY;
    t[i].parent = NULL;
  }

  // Pick a root and set it's key to 0
 // t[0].key = 0;

  while(arrSize > 0){
    // Find the lowest weight
    
    // Subtract that element from Q
    arrSize--;
  }

}



// ****************************************************************
//
//		      Kruskal Helper Functions
//
// ****************************************************************



// Finds the head of the subtree with the specified element
int find(Subtree subtrees[], int findMe) {

  if(subtrees[findMe].head != findMe)
    subtrees[findMe].head = find(subtrees, subtrees[findMe].head);

  return subtrees[findMe].head;
}



// ****************************************************************



// Combines two subtrees
void Union(Subtree subtrees[], int v1, int v2){
  int vt1 = find(subtrees, v1);
  int vt2 = find(subtrees, v2);



// Find the tree with the lower amount of elements and combine it to the bigger one

  // If vt1 has more elements than vt2
  // Add vt1 to vt2
  if(subtrees[vt1].numElements < subtrees[vt2].numElements){
    subtrees[vt1].head = vt2;
  }

  // If vt1 has less elements than vt2
  // Add vt2 to vt1
  else if(subtrees[vt1].numElements > subtrees[vt2].numElements){
    subtrees[vt2].head = vt1;
  }

  // If vt1 = vt2
  // Then set vt2's head to vt1
  else {
    subtrees[vt2].head = vt1;
    subtrees[vt1].numElements++;
  }

}



// ****************************************************************



// Used for the qsort function
int Compare(const void * a, const void * b){
  Edge * a1 = (Edge*)a;
  Edge * b1 = (Edge*)b;

  return a1->weight > b1->weight;
}


// ****************************************************************
//
//                      Prim Helper Functions
//
// ****************************************************************


